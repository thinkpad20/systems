#!/usr/bin/python

import sys

operations_dict = {"add":"+", "sub":"-",
				   "and":"&", "or":"|",
				   "not":"!", "neg":"-",
				   "lt":"JLT", "gt":"JGT",
				   "eq":"JEQ", "leq":"JLE",
				   "geq":"JGE"}

vars_dict = {"this":("THIS","M"),
			 "that":("THAT","M"),
			 "argument":("ARG","M",),
			 "local":("LCL","M",),
			 "static":("f.%d","M",),
			 "temp":("TEMP","A",)}

start = "@SP\nAM=M-1\n"
end = "@SP\nM=M+1\n"

binary_template = start + "D=M\n\
@SP\n\
AM=M-1\n\
M=M%sD\n" + end

unary_template = start + "M=%sM\n" + end

comp_template = start + "D=M\n\
@SP\n\
AM=M-1\n\
D=M-D\n\
@COMP.%d.TRUE\n\
D;%s\n\
@COMP.%d.FALSE\n\
0;JMP\n\
(COMP.%d.TRUE)\n\
@SP\n\
A=M\n\
M=-1\n\
@SP\n\
M=M+1\n\
@COMP.%d.END\n\
0;JMP\n\
(COMP.%d.FALSE)\n\
@SP\n\
A=M\n\
M=0\n" + end + "(COMP.%d.END)\n"

push_tail_template = "@SP\n\
A=M\n\
M=D\n\
@SP\n\
M=M+1\n"

push_const_template = "@%d\nD=A\n" + push_tail_template

push_var_template = "@%d\n\
D=A\n\
@%s\n\
A=%s+D\n\
D=M\n" + push_tail_template

push_staticpointer_template = "@%s\nD=M\n" + push_tail_template

pop_template = "@%d\n\
D=A\n\
@%s\n\
D=%s+D\n\
@R13\n\
M=D\n\
@SP\n\
AM=M-1\n\
D=M\n\
@R13\n\
A=M\n\
M=D\n"

pop_staticpointer_template = "@SP\n\
AM=M-1\n\
D=M\n\
@%s\n\
M=D"


type_dict = {"add":"arithmetic", "sub":"arithmetic",
				   "and":"arithmetic", "or":"arithmetic",
				   "not":"arithmetic", "neg":"arithmetic",
				   "lt":"arithmetic", "gt":"arithmetic",
				   "eq":"arithmetic", "leq":"arithmetic",
				   "geq":"arithmetic", 
				   "push":"memory", "pop":"memory"}

binary_ops = ["add", "sub", "and", "or"]
unary_ops = ["not", "neg"]
comp_ops = ["lt", "gt", "eq", "leq", "geq"]
	

op_count = 0
line_count = 0
output = ["// Assembly file generated by my awesome VM compiler\n"]

def compile_operation(op):
	global line_count

	if (op[0:2] == "//") or (len(op.split()) == 0):
		return ""

	# print "input: " + op
	operation = op.split()[0]
	header = "// '" + op +  "' (line " + str(line_count) + ")\n"
	line_count += 1

	if type_dict[operation] == "arithmetic":
		return header + compile_arithmetic(op)
	elif type_dict[operation] == "memory":
		return header + compile_memory(op)

def compile_arithmetic(op):
	global op_count
	out_string = ""
	if op in comp_ops:
		out_string += comp_template % (op_count, operations_dict[op], op_count, \
			op_count, op_count, op_count, op_count)
		op_count += 1
	elif op in unary_ops:
		out_string += unary_template % operations_dict[op]
	else:
		out_string += binary_template % operations_dict[op]
	return out_string

def compile_memory(op):
	global output
	instructions = op.split()
	inst = instructions[0]
	argtype = instructions[1]
	val = int(instructions[2])
	if inst == "push":
		if argtype == "constant":
			return push_const_template % val
		elif argtype == "static":
			return push_staticpointer_template % ("f." + str(val))
		elif argtype == "pointer":
			if val == 0:
				return push_staticpointer_template % ("THIS")
			else:
				return push_staticpointer_template % ("THAT")
		else:
			return push_var_template % (val, vars_dict[argtype][0], vars_dict[argtype][1])
	elif inst == "pop":
		if argtype != "constant":
			if argtype == "static":
				return pop_staticpointer_template % ("f." + str(val))
			elif argtype == "pointer":
				if val == 0:
					return pop_staticpointer_template % "THIS"
				else:
					return pop_staticpointer_template % "THAT"
			else:
				return pop_template % (val, vars_dict[argtype][0], vars_dict[argtype][1])

def main():
	global output

	if len(sys.argv) == 1:
		inputfname = "test.txt"
	else:
		inputfname = sys.argv[1]
	outputfname = inputfname.split('.')[0] + ".asm"

	inputf = open(inputfname)
	output += ["// Input filename: %s\n" % inputfname]
	
	for line in inputf.readlines():
		output += [compile_operation(line.strip())]

	outputf = open(outputfname, 'w')
	for outl in output:
		outputf.write(outl)

	outputf.write("(END)\n@END\n0;JMP");
	inputf.close()
	outputf.close()
	print "Output written to " + outputfname


if __name__ == "__main__":
	main()

